Здавствуйте, в этом туториале мы рассмотрим как разработать очень простую, но контролируемую форму в React,
сфокусировавшись на качестве кода.

При разработке нашей формы мы будем следовать принципам "KISS", "YAGNI", "DRY".
Для успешного прохождения данного туториала вам не нужно знать этих принципов, я буду
объяснять их по ходу дела. Однако, я полагаю, что вы хорошо владеете современным javascript и умеете <a href="https://ru.reactjs.org/docs/thinking-in-react.html">мыслить на React</a>.

<h3>Структура туториала:</h3>
<ul>
  <li>За дело! Пишем простую форму, используя KISS и YAGNI</li>
  <li>Рефакторинг и DRY</li>
  <li>Что еще можно сделать?</li>
  <li>О, нет! Не делайте так, пожалуйста!</li>
  <li>Выводы</li>
</ul>



<h2>За дело! Пишем простую форму, используя KISS и YAGNI</h2>
Итак, представим, что у нас есть задание реализовать форму авторизации:
<source lang="javascript">
const logInData = {
  nickname: "Vasya",
  email: "pupkin@gmail.com",
  password: "Reac5$$$"
};
</source>

Начнем нашу разработку с того, что вспомним принципы KISS, YAGNI и забудем остальные принципы.

KISS - "Оставте код простым и тупым". С пониманием, что такое простой код обычно проблем не
возникает. Но что значит "тупой" код? В моем понимании код тупой, когда решает задачу, используя минимальное количество абстракций,
а вложенность этих абстракций друг в друга тоже минимальна.

YAGNI - "Вам это не понадобится". Код должен уметь делать только то, для чего он написан. То есть мы не создаем никакой 
функционал, который понадобится потом или который делает приложение лучше на наш взгляд.
Делаем только то, что нужно конкретно для реализации поставленной задачи.

Давайте будем строго следовать этим принципам, но так же учтем: 
- <code>initialData<code/> и <code>onSubmit<code/> для <code>LogInForm<code/> приходит с верху (это полезный прием, особенно когда форма должна уметь обрабатывать create и update одновременно).
- наша форма должна состоять только из контролируемых компонентов (ведь без этого толку от React мало) 
- должна иметь для каждого поля label
- упускаем стилизацию, потому что она нам не интересна
- упускаем валидацю, потому что это тема для отдельного туториала.

Пожалуйста, подумайте, как бы вы реализовали форму, следуя всему, что написано выше.

Пропускаю место для этого!
































У меня форма получилась такой.

<source lang="javascript">  
  const LogInForm = ({ initialData, onSubmit }) => {
    const [logInData, setLogInData] = useState(initialData);
  
    const handleSubmit = e => {
      e.preventDefault();
      onSubmit(logInData);
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <label>
          Enter your nickname
          <input
            value={state.nickname}
            onChange={e => setState({ ...state, nickname: e.target.value })}
          />
        </label>
        <label>
          Enter your email
          <input
            type="email"
            value={state.email}
            onChange={e => setState({ ...state, email: e.target.value })}
          />
        </label>
        <label>
          Enter your password
          <input
            type="password"
            value={state.password}
            onChange={e => setState({ ...state, password: e.target.value })}
          />
        </label>
        <button>Submit</button>
      </form>
    );
  };
</source>

Ваше решение, скорее всего, чем-то отличается, ведь каждый разработчик мыслит по-своему, даже, несмотря на жесткие рамки. 
Вы можете создать для каждого поля свое состояние, а потом собирать его заново для отправки, или выносить функции-обработчики в отдельную переменную, 
в любом случае это не важно.

Но если вы сразу создали одну функцию обработчик для всех полей, то это уже не является "тупейшим" решением задачи. 
А наша цель на этом этапе, создать максимально простой и "тупой" код.
Для того, чтобы потом посмотреть на всю картинку и выделить самые лучше абстракции.

Если у вас получился точно такой же код, это круто и означает, что наше с вами мышление сходится!

Далее мы будем работотать с этим кодом. Он простой, рабочий, но пока далек от идеала.

<h2>Рефакторинг и DRY</h2>
Пришло время вспомнить о принципе DRY

DRY, упрощенная формулировка - "не дублируйте свой код". Исходя из упрощенной формулировки принцип кажется простым, но в нем есть подвох. 
Для избавления от дублирования кода нужно создавать абстракции. Если эти абстракции будут не достаточно
хороши, мы нарушим принцип KISS. Также важно понимать, что DRY нужен не для того, чтобы писать код быстрее.
Его задача - упростить чтение и поддержку нашего решения. Потому не старайтесь придумать абстракции сразу,
лучше сделать простую реализацию какой-то части кода, а потом хорошо подумать, какие абстракции создать,
чтобы упростить чтение кода засчет очевидных абстракций и уменьшить количество мест для изменений, когда они понадобятся.
<b>Чеклист правильной абстракции:</b>
<ul>
  <li>Имя абстракции полностью соответствует ее назначению</li>
  <li>Абстракция выполняет конкретную, понятную задачу</li>
  <li>Чтение кода в который была введена абстракция улучшилось</li>
</ul>

Что ж, приступим к рефакторингу.
А у нас есть ярко выраженный дублирующийся код.
<source lang="xml">
  <label>
    Enter your email
    <input
      type="email"
      value={state.email}
      onChange={e => setState({ ...state, email: e.target.value })}
    />
  </label>
</source>

В данном коде дублируется композиция из 2-х элементов: <code>label</code>, <code>input</code>.
Давайте объеденим их в новую абстракцию <code>InputField</code>
<source lang="javascript">
  const InputField = ({ label, type, value, onChange }) => (
    <label>
      {label}
      <input
        type={type}
        value={value}
        onChange={onChange}
      />
    </label>
  );
</source>

Теперь наш <code>LogInForm</code> выглядит так.

<source lang="javascript">
  const LogInForm = ({ initialData, onSubmit }) => {
    const [logInData, setLogInData] = useState(initialData);
  
    const handleSubmit = e => {
      e.preventDefault();
      onSubmit(logInData);
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <InputField
          label="Enter your nickname"
          value={state.nickname}
          onChange={e => setLogInData({ ...state, nickname: e.target.value })}
        />
        <InputField
          type="email"
          label="Enter your email"
          value={state.email}
          onChange={e => setLogInData({ ...state, email: e.target.value })}
        />
        <InputField
          type="password"
          label="Enter your password"
          value={state.password}
          onChange={e => setLogInData({ ...state, password: e.target.value })}
        />
        <button>Submit</button>
      </form>
    );
  };
</source>
Читать стало проще. Имя абстракции соответсвует задаче, которую она решает. Цель компонента очевидна. Кода стало меньше. 
Значит мы идем в правильном направлении!

Сейчас видно, что в <code>InputField.onChange</code> дублируется логика.
То, что там происходит, можно разбить на 2 этапа.

<source lang="javascript">
  const stage1 = e => e.target.value
  const stage2 = password => setLogInData({ ...state, password })
</source>

Первая функция описывает детали получения значения с события нашего <code>input</code>.
У нас есть на выбор 2 абстракции, в которых мы можем хранить эту логику: <code>InputField</code> и <code>LogInForm</code>.

Для того, чтобы наверняка правильно определиться к какой из абстракций нам нужно отнести свой код,
прийдется обратиться к полной формулировке принципа DRY: "Каждая часть знания должна иметь единственное, 
непротиворечивое и авторитетное представление в рамках системы".

Частью знания в конкретном примере является знание о том, как получать значение из события в <code>input</code>.
Если мы будем это знание хранить в нашем <code>LogInForm</code>, то очевидно, что при использовании нашего
<code>InputField</code> в другой форме, нам прийдется продублировать наше знание, либо вынести его в одельную абстракцию
и использовать ее оттуда. А исходя из принципа KISS, у нас должно быть минимально возможное количество абстракций.
Действительно, зачем нам создавать еще одну абстракцию, если мы можем просто поместить эту логику в нашем <code>InputField</code>,
и внешний код не будет знать ничего о том, как работает input внутри самого <code>InputField</code>, он будет просто принимать готовое значение, 
такое же, как передает внутрь.

Если вас смущает, что вам в будущем может понадобиться событие, вспомните о принципе YAGNI. Всегда 
можно будет добавить дополнительный prop <code>onChangeEvent</code> в наш компонент <code>InputField</code>.

А до тех пор <code>InputField</code> будет выглядеть так: 

<source lang="javascript">
  const InputField = ({ label, type, value, onChange }) => (
    <label>
      {label}
      <input
        type={type}
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </label>
  );
</source>

Таким образом соблюдается однородность типа при вводе и выводе в компонент и скрывается 
истинная природа происходящего для внешнего кода. Если нам в будущем понадобится другой компонент ui, например, checkbox или select,
то в нем мы тоже будем сохранять однородность типа на вводе-выводе. 
Такой подход дает нам дополнительную гибкость, так как наша форма может
работать с любыми источниками ввода-вывода без надобности плодить дополнительные уникальные обработчики для каждого.
Этот эвристический прием встроен по-умолчанию во многие фреймворки. 
Например, это основная идея <code>v-model</code> во <code>Vue</code>, который многие любят за его простоту работы с формами.

Вернемся к делу, обновим наш компонент <code>LogInForm</code> в соответсвии с изменениями в <code>InputField</code>:

<source lang="javascript">
  const LogInForm = ({ initialData, onSubmit }) => {
    const [logInData, setLogInData] = useState(initialData);
  
    const handleSubmit = e => {
      e.preventDefault();
      onSubmit(logInData);
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <InputField
          label="Enter your nickname"
          value={state.nickname}
          onChange={nickname => setLogInData({ ...state, nickname })}
        />
        <InputField
          type="email"
          label="Enter your email"
          value={state.email}
          onChange={email => setLogInData({ ...state, email })}
        />
        <InputField
          type="password"
          label="Enter your password"
          value={state.password}
          onChange={password => setLogInData({ ...state, password })}
        />
        <button>Submit</button>
      </form>
    );
  };
</source>

Это выглядит уже совсем неплохо, но мы можем еще лучше!

Колбек, который передается в <code>onChange</code>, всегда делает одно и то же.
В нем меняется только ключ: password, email, nickname.
Значит, мы можем заменить его на такой вызов функции: <code>handleChange('password')</code>

Теперь давайте реализуем эту функцию:

<source lang="javascript">
  const handleChange = fieldName => fieldValue => {
    setLoginData({
      [fieldName]: fieldValue
    });
  };
</source>

Как видите, функция получает аргумент и соханяет его в замыкании обработчика, 
а обработчик тут же возвращается во внешний код. Такие функции, которые как бы принимают аргументы 
по одному за вызов, еще называют каррированными.

Давайте посмотрим на получившийся код:

<source lang="javascript">  
  const LogInForm = ({ initialData, onSubmit }) => {
    const [logInData, setLogInData] = useState(initialData);
  
    const handleSubmit = e => {
      e.preventDefault();
      onSubmit(logInData);
    };
  
    const handleChange = fieldName => fieldValue => {
      setLogInData({
        [fieldName]: fieldValue,
      });
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <InputField
          label="Enter your nickname"
          value={state.nickname}
          onChange={handleChange('nickname')}
        />
        <InputField
          label="Enter your email"
          value={state.email}
          onChange={handleChange('email')}
        />
        <InputField
          label="Enter your password"
          value={state.password}
          onChange={handleChange('password')}
        />
        <button>Submit</button>
      </form>
    );
  };
  
  // InputField.js
  const InputField = ({ label, value, onChange }) => (
    <label>
      {label}
      <input value={value} onChange={e => onChange(e.target.value)} />
    </label>
  );
</source>

Данный код является короткой, лаконичной и в меру декларативной реализацией поставленной задачи.
Дальнейшей его рефакторинг в контексте задачи, на мой взгляд, не имеет смысла.

<h2>Что еще можно сделать?</h2>

Если у вас много форм в проекте, то вы можете вынести рассчет handleChange в отдельный хук <code>useFieldChange</code>:

<source lang="javascript">
  // hooks/useFieldChange.js
  const useFieldChange = setState => fieldName => fieldValue => {
    setState({
      [fieldName]: fieldValue
    });
  };
  // Form.js
  const handleChange = useFieldChange(setState);
</source>

Так как это чистая функция (имеется ввиду при первом вызове, потому что возвращает всегда одинаковую функцию), 
это не обязательно должен быть хук. 
Но хук смотрится концептуально более правильным и природным решением для React.

Теперь можно добавить поддержку <code>callback</code> на месте <code>fieldValue</code>, чтобы полностью
повторить поведение обычного <code>setState</code> из <code>React</code>

<source lang="javascript">
  const isFunc = (val) => typeof val === "function";

  const useFieldChange = setState => fieldName => fieldValue => {
    setState((state) => {
      [fieldName]: isFunc(fieldValue) ? fieldValue(state) : fieldValue,
    });
  };
</source>

Пример использования с нашей формой:

<source lang="javascript">  
  const LogInForm = ({ initialData, onSubmit }) => {
    const [logInData, setLogInData] = useState(initialData);
    const handleChange = useFieldChange(setLogInData);
  
    const handleSubmit = e => {
      e.preventDefault();
      onSubmit(logInData);
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <InputField
          label="Enter your nickname"
          value={state.nickname}
          onChange={handleChange('nickname')}
        />
        <InputField
          label="Enter your email"
          value={state.email}
          onChange={handleChange('email')}
        />
        <InputField
          label="Enter your password"
          value={state.password}
          onChange={handleChange('password')}
        />
        <button>Submit</button>
      </form>
    );
  };
</source>

Но все это вам делать не нужно в нашем случае! Потому, что это противоречит принципу YAGNI,
следуя которому мы не должны делать то, что нам не нужно для решения конкретной задачи. 
Если у вас только 1 форма, то реальной пользы от таких телодвижений мало, 
ведь мы сократим код нашего компонента только на 3 строчки, но ввели дополнительную абстракцию, 
скрыв определенную логику формы, которую лучше держать на поверхности.



<h2>О, нет! Не делайте так, пожалуйста!</h2>

<h3>Формы из замоканых конфигов</h3>
Посмотрите на этот код:
<source lang="javascript">  
  const Form = () => (
    <form onSubmit={handleSubmit}>
      <InputField
        label="Enter your nickname"
        value={state.nickname}
        onChange={handleChange('nickname')}
      />
      <InputField
        label="Enter your email"
        value={state.email}
        onChange={handleChange('email')}
      />
      <InputField
        label="Enter your password"
        value={state.password}
        onChange={handleChange('password')}
      />
      <button>Submit</button>
    </form>
  );
</source>
Некоторым разработчикам может показаться, что здесь у нас дублирование кода,
ведь мы же вызываем один и тот же компонент InputField, 
передавая туда одни и те же параметры label, value и onChange.
И они начинают за-DRY-ивать собственный код, чтобы избежать мнимого дублирования.
Часто это делают примерно так:
<source lang="javascript">  
  const fields = [
    {
      name: 'nickname',
      label: 'Enter your nickname',
    },
    {
      name: 'email',
      label: 'Enter your email',
    },
    {
      name: 'password',
      label: 'Enter your password',
    },
  ];

  const Form = () => (
    <form onSubmit={handleSubmit}>
      {fields.map({ name, label } => (
        <InputField
          label={label}
          value={state[name]}
          onChange={handleChange(name)}
        />
      )}
      <button>Submit</button>
    </form>
  );
</source>
В итоге с 15 строчек кода получаем 14. Браво! Вот это я понимаю DRY.
Если у нас здесь будет 100 таких input-ов, то мы получим 500 и 402 строчки соответсвенно.
Но, как результат, мы получили более сложный код, нарушив принцип KISS. 
Ведь теперь он состоит из 2-х абстракций, fields и алгоритм, который превращает его в дерево React-элементов 
(да, алгоритм - это тоже абстракция), и 
при чтении этого кода нам прийдется постоянно прыгать между ними.

Но самая большая проблема этого кода - это его поддержка и расширение.
Представте, что с ним случится, если:
<ul>
  <li>Добавится еще несколько типов полей с разными возможными свойствами</li>
  <li>Поля могут рендериться или не рендериться на основе ввода других полей</li>
  <li>Некоторые поля требуют какой-то дополнительной обработки при изменении</li>
  <li>Значения в селектах зависит от прерыдущих селектов</li>
  <li>Можно продолжать долго...</li>
</ul>

Для реализации этого всегда прийдется хранить какие-то функции в вашем конфиге, а код, который
рендерит конфиг, постепенно превратится в Франкенштейна, принимая кучу разных пропсов и
закидывая их по разным компонентам.

Код, который был написан до этого, основанный на композиции компонентов, будет спокойно
расширяться, меняться как угодно при этом не сильно усложнясь, а все <b>благодаря отсутсвию промежуточной 
  абстракции</b> - алгоритма, который строит дерево React-элементов из нашего конфига.


<h3>Бесполезная оптимизация</h3>

Многие разработчики оборачивают все обработчики и компоненты без разбору в <code>useCallback</code> и <code>memo</code>.
Пожалуйста, не делайте этого! Данные хуки предоставлены разработчиками React не потому, что React медленный
и все нужно оптимизировать. Они дают пространство для оптимизации вашему приложению в случае, если вы столкнетесь
с проблемами производительности. И даже, если вы столкнулись с такими проблемами, не нужно оборачивать весь проект в <code>memo</code> и <code>useCallback</code>.
Используйте <a href="https://ru.reactjs.org/docs/profiler.html">Profiler</a> для выявления проблем и только потом мемоизацию в нужном месте.
Мемоизация всегда сделает ваш код сложнее, но не всегда производительнее. Если я вас не убедил, почитайте <a href="https://kentcdodds.com/blog/usememo-and-usecallback">отдельную статью на эту тему<a/>.


<h2>Выводы</h2>
<ul>
  <li>
    Формы в React - это просто. Проблемы с ними разработчики создают себе сами, а также несовершенная документация React,
    в которой эта тема раскрыта плохо.
  </li>
  <li>Для удобной работы с вашими компонентами держите ввод и вывод aka value и onChange одного типа,
    это позволит вам использовать хук useFieldChange описанную выше и получать чуть более многословный,
    но не мение мощный аналог <code>v-model</code> из <code>Vue</code> для комфортной работы.</li>
  <li>При написании кода следуйте принципам KISS и YAGNI в первую очередь, а затем DRY, но осторожно, 
    чтобы случайно не создать плохую абстракцию.</li>
  <li>Избегайте описывания ваших форм с помощью конфигов, если такой подход не навязывает вам ваш фреймворк или библиотека,
    ведь там алгоритм по превращению конфигов в React-дерево скрыт за абстракцией фреймворка.
  </li>
  <li>Всегда избегайте оптимизаций, если в них нет явной необходимости.</li>
</ul>

<h3>P.S</h3>
Изначально я планировал написать о декларативной валидации сложных вложенных форм, но в итоге, решил,
что нужно подготовить аудиторию к этому, чтобы картина была максимально полной.
Следующий туториал будет о валидации простой формы, реализованной в этом туториале.
Огромное спасибо, всем кто дочитал до конца! 
Не важно, как вы пишите код или чем занимаетесь вообще, главное - получайте от этого удовольствие.
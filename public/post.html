Здавствуйте, в этом туториале мы рассмотрим как разрабатывать формы в React, 
основное внимание уделив валидации.

<h2>Чего ожидать?</h2>

При разработке нашей формы мы будем следовать принципов KISS, YAGNI, DRY а также
стараться делать наш код как можно более декларативным используя всякие 
штуки из функционального программирования 
такие как чистые функции, функции высшего порядка, каррирование и т.д.
Но для успешного прохождения данного туториала вам ничего этого знать не нужно, я буду
объяснять по-ходу дела. Однако я пологаю что вы владеете основными понятиями React и умеете
<a href="https://ru.reactjs.org/docs/thinking-in-react.html">мыслить на React</a>. 

<h2>К делу!</h2>

И так представим что у нас есть задание
реализовать форму отправляющую на сервер что-то такое:
<source lang="javascript">
const logInRequest = {
  nickname: "Vasya",
  email: "pupkin@gmail.com",
  password: "Reac5$$$"
};
</source>

Принцип KISS говорит нам: "код должен быть максимально простым".
"Изи" - подумали мы, и написали самое простое решение в лоб.
Вот оно, это решение:
<source lang="javascript">
  const defaultState = {
    name: "",
    email: "",
    password: "",
  };
  
  const Form = () => {
    const [state, setState] = useState(defaultState);
  
    const handleSubmit = () => {
      // TODO: post data to server
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <label>
          Enter your nickname
          <input
            value={state.nickname}
            onChange={e => setState({ ...state, nickname: e.target.value })}
          />
        </label>
        <label>
          Enter your email
          <input
            type="email"
            value={state.email}
            onChange={e => setState({ ...state, email: e.target.value })}
          />
        </label>
        <label>
          Enter your password
          <input
            type="password"
            value={state.password}
            onChange={e => setState({ ...state, password: e.target.value })}
          />
        </label>
        <button>Submit</button>
      </form>
    );
  };
</source>

И так мы получили простой, рабочий, но пока не идеальный код.
Обычно статьи по разработке форм в react на чем-то таком и заканчиваются, но мы пойдем дальше! 
Давайте вспомним о принципе DRY.

Принцип DRY говорит нам: "не дублировуй свой код"

А у нас есть ярко выраженный дублирующийся код.
<source lang="xml">
  <label>
    Enter your email
    <input
      type="email"
      value={state.email}
      onChange={e => setState({ ...state, email: e.target.value })}
    />
  </label>
</source>

В данном коде дублируется композиция из 2-х элементов: <var>label</var>, <var>input</var>.
Давайте объеденим их в новую абстракцию <var>InputField</var>
<source lang="javascript">
  const InputField = (label, value, onChange) => (
    <label>
      {label}
      <input
        value={value}
        onChange={onChange}
      />
    </label>
  );
</source>

Теперь наш <var>Form</var> будет возвращать такой jsx
<source lang="javascript">
  <InputField
    label="Enter your nickname"
    value={state.nickname}
    onChange={e => setState({ ...state, nickname: e.target.value })}
  />
  <InputField
    label="Enter your email"
    value={state.email}
    onChange={e => setState({ ...state, email: e.target.value })}
  />
  <InputField
    label="Enter your password"
    value={state.password}
    onChange={e => setState({ ...state, password: e.target.value })}
  />
  <button>Submit</button>
</source>

Стало проще, но в функции onChange дублируется логика.
То что там происходит можно разбить на 2 этапа
<source lang="javascript">
  e => e.target.value
  password => setState({ ...state, password })
</source>
Первая функция описывает детали получения значения с события нашего <var>input</var>.
Поскольку это детали работы <var>input</var>, лучше вынести этот код внутрь InputField
<source lang="javascript">
  const InputField = (label, value, onChange) => (
    <label>
      {label}
      <input
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </label>
  );
</source>
Таким образом соблюдается однородность типа при вводе и выводе в компоненте и скривается 
истенная природа происходящего. Такой подход дает нам дополнительную гибкость так как мы можем
работать с любыми источниками ввода не задумываясь о его реализации и соответсвенно 
обрабатывать все осточники ввода одинаково.
Обновим наш компоненте Form, в соответсвии с изменениями в InputField:
<source lang="javascript">
  <InputField
    label="Enter your nickname"
    value={state.nickname}
    onChange={nickname => setState({ ...state, nickname })}
  />
  <InputField
    label="Enter your email"
    value={state.email}
    onChange={email => setState({ ...state, email })}
  />
  <InputField
    label="Enter your password"
    value={state.password}
    onChange={password => setState({ ...state, password })}
  />
</source>
Это выглядит уже совсем не плохо, но мы можем лучше! 
Колбек который передается в onChange всегда делает одно и то же: 
записывает состояние значение в состояние с определенным именем.
То есть постоянно меняется только ключ в состоянии, остальная логика не меняется.
А значит мы можем создать функцию которая будет принимать только ключ в состоянии
и возвращать нужный нам обработчик.
И поможет нам создать такую функцию "каррирование".
Если говорить упрощенно, то каррированая функция - это такая
функция которая выполнится только при получении всех аргументов.  
Что ж лучше на примере, создадим каррированную функцию для нашего onChange
<source lang="javascript">
  const handleChange = fieldName => fieldValue => {
    setState({
      [fieldName]: fieldValue
    });
  };
</source>
Как видите функция будет получать аргументы постепенно каждый раз 
сохраняя в замыкании предыдущий.
Давайте используем ее в наш <var>Form</var> и посмотри на весь код целяком.
<source lang="javascript">
  const defaultState = {
    nickname: '',
    email: '',
    password: '',
  };
  
  const Form = () => {
    const [state, setState] = useState(defaultState);
  
    const handleSubmit = e => {
      e.preventDefault();
      // TODO: post your data to api
    };
  
    const handleChange = fieldName => fieldValue => {
      setState({
        [fieldName]: fieldValue,
      });
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <InputField
          label="Enter your nickname"
          value={state.nickname}
          onChange={handleChange('nickname')}
        />
        <InputField
          label="Enter your email"
          value={state.email}
          onChange={handleChange('email')}
        />
        <InputField
          label="Enter your password"
          value={state.password}
          onChange={handleChange('password')}
        />
        <button>Submit</button>
      </form>
    );
  };
  
  const InputField = ({ label, value, onChange }) => (
    <label>
      {label}
      <input value={value} onChange={e => onChange(e.target.value)} />
    </label>
  );
</source>





















































При этом требования к полям такие (сейчас это можно пропустить и вернуться позже):

<ul>
  <li>
    nickname
    <ul>
      <li>не должно быть пустым.</li>
      <li>поле должно состоять только из буков английского алфавита</li>
      <li>длинна не меньше 2 букв</li>
      <li>длинна не больше 15 букв</li>
    </ul>
  </li>
  <li>
    email
    <ul>
      <li>не должно быть пустым.</li>
      <li>поле должно быть корректным имейлом</li>
    </ul>
  </li>
  <li>
    password
    <ul>
      <li>не должно быть пустым.</li>
      <li>должня быть минимум 1 заглавная буква</li>
      <li>должна быть минимум 1 строчная буква</li>
      <li>минимум 1 число</li>
      <li>минимум 1 символ</li>
      <li>не меньше 8 символо в сумме</li>
    </ul>
  </li>
</ul>

<source lang="javascript">
  const defaultState = {
    name: "",
    email: "",
    password: "",
  };
  
  const defaultErrors = {
    name: "",
    email: "",
    password: "",
  };
  
  const Form = () => {
    const [state, setState] = useState(defaultState);
    const [errors, setErrors] = useState(defaultErrors);
  
    const validate = () => {
      const errors = {};
      const isValid = false;
      // TODO: implement validation here
      setErrors(errors);
      return isValid;
    };
  
    const handleSubmit = () => {
      if (validate()) {
        // TODO: post data to server
      }
    };
  
    return (
      <form onSubmit={handleSubmit}>
        <label>
          name
          <input
            value={state.name}
            onChange={e => setState({ ...state, name: e.target.value })}
          />
        </label>
        {// Avoid inline styles in realworld code}
        <p style={{ color: "red" }}>{errors.name}</p> 
        <label>
          email
          <input
            type="email"
            value={state.email}
            onChange={e => setState({ ...state, email: e.target.value })}
          />
        </label>
        <p style={{ color: "red" }}>{errors.email}</p>
        <label>
          password
          <input
            type="email"
            value={state.password}
            onChange={e => setState({ ...state, password: e.target.value })}
          />
        </label>
        <p style={{ color: "red" }}>{errors.password}</p>
        <button>Submit</button>
      </form>
    );
  };
</source>